"use strict";

var glob = require('glob');
var through = require('through2');
var fs = require('fs');
var path = require('path');
var Twig = require('twig');
var twig = Twig.twig;
var gutil = require('gulp-util');
var _ = require('lodash');

var PluginError = gutil.PluginError;

var currentTwigVersion = Twig.VERSION.split('.');
var checkVersion = function (mj, mi, fx, supress) {
  if (supress) {
    return currentTwigVersion[0] == mj && currentTwigVersion[1] == mi && currentTwigVersion[2] == fx;
  }
  if (currentTwigVersion[0] != mj) {
    console.error("Twig has another version");
  } else {
    if (currentTwigVersion[1] != mi) {
      console.warn("Twig has another version");
    } else {
      if (currentTwigVersion[2] != fx) {
        console.log("Twig has another version");
        return false;
      } else {
        return true;
      }
    }
  }
};
if (checkVersion(0, 8, 5, true)) {
  console.error("This version of Twig has bug!")
}

/*
 * Change Twig to add additional compile options
 * (main feature: parse dependencies and add ones in requirejs define arguments)
 */

Twig.cache(false);//for watch

Twig.extend(function (Twig) {
  /*
   * Add ability of loading inline templates
   */
  Twig.compiler.wrap = function (id, tokens) {
    id = id.split("\\").join("/");//windows fix
    return 'var autoGeneratedData = {id:"' + id.replace('"', '\\"') + '", allowInlineIncludes: true, data:' + tokens + ', precompiled: true};\n\n';
  };
  /*
   * When compile amd module (that is all we can...) pass additional arguments (template, options)
   */
  Twig.compiler.compile = function (template, options) {
    // Get tokens
    var tokens = JSON.stringify(template.tokens),
        id     = template.id,
        output;

    if (options.module) {
      if (Twig.compiler.module[options.module] === undefined) {
        throw new Twig.Error("Unable to find module type " + options.module);
      }
      output = Twig.compiler.module[options.module](id, tokens, options.twig, template, options);
    } else {
      output = Twig.compiler.wrap(id, tokens);
    }
    return output;
  };
  /*
   * Customize Twig errors
   */
  Twig.log = {
    trace: function () {
      if (Twig.trace) {
        gutil.log(gutil.colors.grey(Array.prototype.slice.call(arguments)));
      }
    },
    debug: function () {
      if (Twig.debug) {
        gutil.log(gutil.colors.grey(Array.prototype.slice.call(arguments)));
      }
    },
    error: function () {
      gutil.log(gutil.colors.grey(Array.prototype.slice.call(arguments)));
    }
  };
  /*
   * Inject in parsing and get static (not evaluated!) template dependencies
   */
  var overrideOld = {},
      override    = function (name, i) {//Twig.
        overrideOld[name] = Twig.logic.handler[name].compile;
        Twig.logic.handler[name].compile = function (token) {
          var match      = token.match,
              expression = match[i].trim();
          if (!this.compiliationMetadata) {
            this.compiliationMetadata = [];
          }
          this.compiliationMetadata.push(expression);
          return overrideOld[name].apply(this, arguments);
        };
      };
  override('Twig.logic.type.extends', 1);
  override('Twig.logic.type.include', 2);
  override('Twig.logic.type.use', 1);
  override('Twig.logic.type.import', 1);

  /*
   * There is Main work
   */
  Twig.compiler.module.amd = function (id, tokens, pathToTwig, template, options) {
    var requiredViews = [];
    // * *  old way of getting extend
    //try {
    //    Twig.parse.apply(template, [template.tokens, {}])
    //} catch (e) {
    //    gutil.log(gutil.colors.red('while compiling ' + id + ' was error'), e);
    //}
    //if (template.extend) {
    //    requiredViews.push(template.extend);
    //}

    requiredViews = requiredViews.concat(_.map(template.compiliationMetadata, function (file) {
      return file && file.replace(/^['"]/, '').replace(/['"]$/, '');
    }));
    /* amd requireds */
    var requireds = _.map(_.filter(requiredViews, function (file) {
      if (!file) {
        return false;
      }
      var isOk = options.compileOptions.willCompile && _.indexOf(options.compileOptions.willCompile, file) !== -1;
      isOk = isOk || _.some(options.compileOptions.lookPaths, function (lookPath) {
          var fileName = path.join(__dirname, lookPath, file);
          //console.log(lookPath, 'lookPath',__dirname);
          return fs.existsSync(fileName);
        });
      if (!isOk) {
        gutil.log(gutil.colors.yellow('while compiling ' + id + ' can\'t find template: ') + file);
      }
      return isOk;
    }), function (v, i) {
      return '"' + options.compileOptions.viewPrefix + v + '"';
    });
    requireds.unshift('"' + pathToTwig + '"');

    requireds = requireds.join(', ');
    return 'define([' + requireds + '], function (Twig) {\n  var twig = Twig.twig, template;\n'
      + '  var currentTwigVersion = Twig.VERSION.split(\'.\');\n'
      + '  var checkVersion = '
      + String(checkVersion) + ";\n"
      + '  checkVersion(' + currentTwigVersion[0] + ',' + currentTwigVersion[1] + ',' + currentTwigVersion[2] + ');\n'
      + Twig.compiler.wrap(id, tokens) + '\ttemplate = twig(autoGeneratedData);\n\ttemplate._autoGeneratedData = autoGeneratedData;//in case You want pass some options\n\treturn template;\n});';
  };
});

module.exports = function (opt) {
  //opt.compileOptions.willCompile = glob.sync(opt.compileOptions.lookPaths[0]);
  function transform(file, enc, cb) {
    if (file.isNull()) return cb(null, file);
    if (file.isStream()) return cb(new PluginError('gulp-twig-compile', 'Streaming not supported'));

    var options = _.merge({
      twig:             'twig',
      'compileOptions': {
        viewPrefix: '',
      }
    }, opt);
    var data;
    try {
      var template = twig({id: file.relative, data: file.contents.toString('utf8'), allowInlineIncludes: true});
      data = template.compile(options);
    } catch (err) {
      return cb(new PluginError('gulp-twig-compile', err));
    }

    file.contents = new Buffer(data);
    file.path = file.path + '.js';

    cb(null, file);
  }

  return through.obj(transform);
};